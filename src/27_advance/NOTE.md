## 01 WorkSpace 和GOPATH
### 1. Go 語言源碼的組織方式
1. 在工作區中，一個代碼包的導入路徑實際上就是從 src 子目錄，到該包的實際存儲位置的相對路徑
2. Go 語言源碼的組織方式就是以環境變量 GOPATH、工作區、src 目錄和代碼包為主線的。一般情況下，Go 語言的 source code file 都需要被存放在環境變量 GOPATH 包含的某個工作區（目錄）中的 src 目錄下的某個代碼包（目錄）中。

### 2. 了解源碼安裝後的結果
1. go程式碼文件以及安裝後的結果文件都會放到某個工作區的 src 子目錄下。
2. 那麼在安裝後如果產生了歸檔文件（xxx.a : 編譯後生成的靜態庫文件），就會放進該工作區的 pkg 子目錄；
   如果產生了可執行文件，就可能會放進該工作區的 bin 子目錄。
3. go程式碼文件會以代碼包的形式組織起來，一個代碼包其實就對應一個目錄。安裝某個代碼包而產生的歸檔文件是與這個代碼包同名的。

放置它的相對目錄就是該代碼包的導入路徑的直接父級。比如，一個已存在的代碼包的導入路徑是
`github.com/labstack/echo`, 那麼執行命令 `go install github.com/labstack/echo`
生成的歸檔文件的相對目錄就是 github.com/labstack， 文件名為 echo.a。

歸檔文件的相對目錄與 pkg 目錄之間還有一級目錄，叫做平台相關目錄。平台相關目錄的名稱是由 build（也稱“構建”）的目標操作系統、下劃線和目標計算架構的代號組成的。比如，構建某個代碼包時的目標操作系統是 Linux，目標計算架構是 64 位的，那麼對應的平台相關目錄就是 linux_amd64。
因此，上述代碼包的歸檔文件就會被放置在當前工作區的子目錄 pkg/linux_amd64/github.com/labstack 中。

```
GOPATH
  |--- WorkSpace1
  |--- WorkSpace2 ----- src
                   |      |--- github.com/labstack/echo
                   |      |--- ...
                   |
                   |
                   |--- pkg
                   |      |--- linux_amd64 (accroding to your computer)
                   |                    |--- github.com/labstack
                   |                    |                     |- echo.a
                   |                    |--- ...
                   |--- bin
```

### 3. 理解構建和安裝 Go 程序的過程
構建使用命令go build，安裝使用命令go install。構
建和安裝代碼包的時候都會執行編譯、打包等操作，並且，這些操作生成的任何文件都會先被保存到某個臨時的目錄中。

- build `source code file` (dependency code)，結果文件只會存在於臨時目錄中。這裡的構建的主要意義在於檢查和驗證。

- build `entry file` (with main(){}, entry point of the executable programs)，結果文件會被搬運到 `entry file` 所在的目錄中(under same directory)。

安裝操作會先執行構建，然後還會進行鏈接操作，並且把結果文件搬運到指定目錄。
- install `source code file` (dependency code)，結果文件會被 move to 它所在工作區的 pkg 目錄下的某個子目錄中。
- install `entry file` (with main(){}, entry point of the executable programs)，那麼結果文件會被 move to 它所在工作區的 bin 目錄中，或者環境變量GOBIN指向的目錄中。

### go build
- `-a` : 不但目標代碼包總是會被編譯，它依賴的代碼包也總會被編譯，即使依賴的是標準庫中的代碼包也是如此。
- `-i`: 如果不但要編譯依賴的代碼包，還要安裝它們的歸檔文件(xxx.a:編譯後生成的靜態庫文件)。

怎麼確定哪些代碼包被編譯了
- 運行go build命令時加入標記-x，這樣可以看到go build命令具體都執行了哪些操作。
  另外也可以加入標記-n，這樣可以只查看具體操作而不執行它們。
- 運行go build命令時加入標記-v，這樣可以看到go build命令編譯的代碼包的名稱。它在與-a標記搭配使用時很有用。


命令go get會自動從一些主流公用代碼倉庫（比如 GitHub）下載目標代碼包，並把它們安裝到環境變量GOPATH包含的第 1 工作區的相應目錄中。如果存在環境變量GOBIN，那麼僅包含命令go程式碼文件的代碼包會被安裝到GOBIN指向的那個目錄。

常用的幾個標記有下面幾種。

-u：下載並安裝代碼包，不論工作區中是否已存在它們。
-d：只下載代碼包，不安裝代碼包。
-fix：在下載代碼包後先運行一個用於根據當前 Go 語言版本修正代碼的工具，然後再安裝代碼包。
-t：同時下載測試所需的代碼包。
-insecure：允許通過非安全的網絡協議下載和安裝代碼包。 HTTP 就是這樣的協議。

Go 語言官方提供的go get命令是比較基礎的，其中並沒有提供依賴管理的功能。目前 GitHub 上有很多提供這類功能的第三方工具，比如glide、gb以及官方出品的dep、vgo等等，它們在內部大都會直接使用go get。

## 02 命令源碼文件 `entry file` (with main(){}, entry point of the executable programs)
- 命令源碼文件是程序的運行入口，是每個可獨立運行的程序必須擁有的。
- Module Programming，會將代碼拆分到多個文件，甚至拆分到不同的代碼包中。但無論怎樣，對於一個獨立的程序來說，命令源碼文件永遠只會也只能有一個。如果有與命令源碼文件同包的源碼文件，那麼它們也應該聲明屬於main包。

1. 命令源碼文件怎樣接收參數
    - Go 語言標準庫中有一個代碼包專門用於接收和解析命令參數。這個代碼包的名字叫flag。
      調用flag包的StringVar函數的代碼
      還有一個與flag.StringVar函數類似的函數，叫flag.String。
      這兩個函數的區別是，後者會直接返回一個已經分配好的用於存儲命令參數值的地址。
    - 函數flag.Parse用於真正解析命令參數，並把它們的值賦給相應的變量
      對該函數的調用必須在所有命令參數存儲載體的聲明和設置之後，並且在讀取任何命令參數值之前進行。

2. 怎樣在運行命令源碼文件的時候傳入參數，又怎樣查看參數的使用說明
    如果想查看該命令源碼文件的參數說明，可以這樣做：
    $ go run demo2.go --help
3. 怎樣自定義命令源碼文件的參數使用說明
    - 最簡單的一種方式就是對變量flag.Usage重新賦值。 flag.Usage的類型是func()，即一種無參數聲明且無結果聲明的函數類型。
      flag.Usage變量在聲明時就已經被賦值了，所以我們才能夠在運行命令 `go run xxx.go --help` 時看到正確的結果
      - 我們在調用flag包中的一些函數（比如StringVar、Parse等等）的時候，實際上是在調用flag.CommandLine變量的對應方法。
    - flag.CommandLine相當於默認情況下的命令參數容器。所以，通過對flag.CommandLine重新賦值，可以定制當前命令源碼文件的參數使用說明。這樣做的好處依然是更靈活地定制命令參數容器。

## 03 源碼文件
- 源碼文件是不能被直接運行的源碼文件(xxx.go)，它僅用於存放program實體，這些program實體可以被其他代碼使用（只要遵從 Go 語言規範的話）。
- 源碼文件(xxx.go)聲明的包名可以與其所在目錄的名稱不同，只要這些文件聲明的 package name一致就可以。
- 同目錄下的源碼文件的代碼包聲明語句要一致。如果目錄中有命令源碼文件，那麼其他種類的源碼文件也應該聲明屬於main包。
- 源碼文件(xxx.go) package name 可以與其所在的目錄的名稱不同。while `go build`，生成的結果文件的主名稱與其父目錄的名稱一致。

- 應該讓聲明的包名與其父目錄的名稱一致。
- 通過名稱，Go 語言自然地把程序實體的訪問權限劃分為了包級私有的和公開的。對於包級私有的程序實體，即使你導入了它所在的代碼包也無法引用到它。
- internal包中聲明的公開代碼實體(with capital Letter)僅能被該代碼包的直接父包及其子包中的代碼引用。

## 04 | 程序實體的那些事兒（上）
### variables declarations
- Go 語言中的類型推斷 `var x = "hello"`, 在編譯期自動解釋表達式類型的能力, 表達式類型就是對表達式進行求值後得到結果的類型
- 短變量聲明的用法 `x := "hello"`, Go 語言的類型推斷再加上一點點語法糖。只能在函數體內部使用短變量聲明。編寫if、for或switch語句的時候，我們經常把它安插在初始化子句中，並用來聲明一些臨時的變量。而相比之下，第一種方式更加通用，它可以被用在任何地方。
- Go 語言是靜態類型的，所以一旦在初始化變量時確定了它的類型，之後就不可能再改變。這就避免了在後面維護的一些問題(得代碼重構變得更加容易)。另外，這種類型的確定是在編譯期完成的，因此不會對程序的運行效率產生任何影響。

### variables redeclarations
- 可以對同一個代碼塊中({...}, func, gobal context)的變量進行重聲明。
- 變量重聲明的前提條件如下。
  1. 由於變量的類型在其初始化時就已經確定了，所以對它再次聲明時賦予的類型必須與其原本的類型相同，否則會產生編譯錯誤。
  2. 變量的重聲明只可能發生在某一個代碼塊中。
  3. 變量的重聲明只有在使用短變量聲明時才會發生，否則也無法通過編譯。
  4. 被“聲明並賦值”的變量必須是多個，並且其中至少有一個是新的變量。這時我們才可以說對其中的舊變量進行了重聲明。
  5. 變量重聲明其實算是一個語法糖（或者叫便利措施）。它允許我們在使用短變量聲明時不用理會被賦值的多個變量中是否包含舊變量。
For Example:
```go
func main() {
	var err error
	n, err := io.WriteString(os.Stdout, "Hello, everyone!\n") // 這裡對`err`進行了重聲明。
	if err != nil {
		fmt.Printf("Error: %v\n", err)
	}
	fmt.Printf("%d byte(s) were written.\n", n)
}
```

## 05 | 程序實體的那些事兒（）


## 07 | array和slice
- `可以把slice看做是對array的一層簡單的封裝`，因為在`每個slice的底層數據結構中，一定會包含一個array`。
- array可以被叫做slice的底層array，而`slice也可以被看作是對array的某個連續片段的引用`。
- Go 語言的slice類型屬於引用類型，同屬引用類型的還有map據類型以及struct類型。
- 在 Go 語言中，如果傳遞的值是引用類型的，那麼就是“傳引用”。如果傳遞的值是值類型的，那麼就是“傳值”。
- 在array和slice之上都可以應用索引表達式，得到的都會是某個元素。我們在它們之上也都可以應用slice表達式，也都會得到一個新的slice。


## 13 | 結構體及其方法的使用法門
- 結構體類型也可以不包含任何字段，可以為這些類型關聯上一些方法，把方法看做是函數的特殊版本。
- (functional programming)函數則是獨立的程序實體。我們可以聲明有名字的函數，也可以聲明沒名字的函數，還可以把它們當做普通的值傳來傳去。我們能把具有相同簽名的函數抽象成獨立的函數類型，以作為一組輸入、輸出（或者說一類邏輯組件）的代表。
- 方法卻不同，它需要有名字，不能被當作值來看待，最重要的是，它必須隸屬於某一個類型。方法所屬的類型會通過其聲明中的接收者（receiver）聲明體現出來。
- 接收者聲明就是在關鍵字func和方法名稱之間的那個圓括號包裹起來的內容，其中必須包含確切的名稱和類型字面量。這個接收者的類型其實就是當前方法所屬的那個類型，而接收者的名稱，則用於在當前方法中引用它所屬的類型的當前值。
- 方法隸屬的類型其實並不局限於結構體類型，但必須是某個自定義的數據類型，並且不能是任何接口類型。


### Promoted / Anonymous / Embedded fields
```go
type Animal struct {
  scientificName string // 學名。
  AnimalCategory    // 動物基本分類。
}
```
字段聲明AnimalCategory代表了Animal類型的一個嵌入字段。 Go 語言規範規定，如果一個字段的聲明中只有字段的類型名而沒有字段的名稱，那麼它就是一個嵌入字段，也可以被稱為匿名字段。我們可以通過此類型變量的名稱後跟“.”，再後跟嵌入字段類型的方式引用到該字段。也就是說，嵌入字段的類型既是類型也是名稱。

- 只要名稱相同，無論這兩個方法的簽名是否一致，被嵌入類型的方法都會“屏蔽”掉嵌入字段的同名方法。
- 因為嵌入字段的字段和方法都可以“嫁接”到被嵌入類型上，所以即使在兩個同名的成員一個是字段，另一個是方法的情況下，這種“屏蔽”現象依然會存在。
- 不過，即使被屏蔽了，我們仍然可以通過鍊式的選擇表達式，選擇到嵌入字段的字段或方法

- `Go 語言中根本沒有繼承的概念，它所做的是通過嵌入字段的方式實現了類型之間的組合`。(Why is there no type inheritance?)。簡單來說，面向對象編程中的繼承，其實是通過犧牲一定的代碼簡潔性來換取可擴展性，而且這種可擴展性是通過侵入的方式來實現的。類型之間的組合採用的是非聲明的方式，我們不需要顯式地聲明某個類型實現了某個接口，或者一個類型繼承了另一個類型。

- 同時，類型組合也是非侵入式的，它不會破壞類型的封裝或加重類型之間的耦合。我們要做的只是把類型當做字段嵌入進來，然後坐享其成地使用嵌入字段所擁有的一切。如果嵌入字段有哪裡不合需求，我們還可以用“包裝”或“屏蔽”的方式去調整和優化。另外，類型間的組合也是靈活的，我們總是可以通過嵌入字段的方式把一個類型的屬性和能力“嫁接”給另一個類型。這時候，被嵌入類型也就自然而然地實現了嵌入字段所實現的接口。再者，組合要比繼承更加簡潔和清晰，Go 語言可以輕而易舉地通過嵌入多個字段來實現功能強大的類型，卻不會有多重繼承那樣複雜的層次結構和可觀的管理成本。接口類型之間也可以組合。在 Go 語言中，接口類型之間的組合甚至更加常見，我們常常以此來擴展接口定義的行為或者標記接口的特徵。

### Method Receiver
- 方法的接收者類型(Methods,Function Receiver)`必須是某個自定義的數據類型，而且不能是接口類型或接口的指針類型`。所謂的值方法，就是接收者類型是非指針的自定義數據類型的方法。

- Methods,Function Receiver
  1. return type:
    - value receiver: copy of value。在該方法內對該副本的修改一般都不會體現在原值上，除非這個類型本身是某個引用類型（比如slice或map）的別名類型。
    - pointer receiver: copy of pointer。我們在這樣的方法內對該副本指向的值進行修改，卻一定會體現在原值上。
  2. 一個`自定義數據類型的方法集合`中僅會包含它的所有`值方法`，而該類型的`指針類型的方法集合`卻囊括了前者的所有方法，`包括所有值方法(value receiver methods)和所有指針方法(pointer receiver methods)`。
    - value receiver: 只能調用到它的值方法。
    - pointer receiver: Go 語言會適時地為我們進行自動地轉譯，使得我們在這樣的值上也能調用到它的指針方法。
      比如，在Cat類型的變量cat之上，之所以我們可以通過`cat.SetName("monster")`修改貓的名字，是因為 Go 語言把它自動轉譯為了`(&cat).SetName("monster")`，即：`先取cat的指針值，然後在該指針值上調用SetName方法`。
  3. 一個類型的方法集合中有哪些方法與它能實現哪些接口類型是息息相關的。如果一個基本類型和它的指針類型的方法集合是不同的，那麼它們具體實現的接口類型的數量就也會有差異，除非這兩個數量都是零。比如，一個指針類型實現了某某接口類型，但它的基本類型卻不一定能夠作為該接口的實現類型


- 方法的定義感覺本質上也是一種語法糖形式，其本質就是一個函數，聲明中的方法接收者就是函數的第一個入參，在調用時go會把施調變量作為函數的第一個入參的實參傳入，比如
  ```go
  func (t MyType) MyMethod(in int) (out int)
  // 可以看作是
  func MyMethod(t Mytype, in int) (out int)

  myType.MyMethod(123)
  // 就可以理解成是調用
  MyMethod(myType, 123)
  // 如果 myType 是 *MyType 指針類型，
  // 則在調用是會自動進行指針解引用，實際就是這麼調用的 MyMethod(*myType, 123)，這麼一理解，值方法和指針方法的區別也就顯而易見了。
  ```


## 09 | map的操作和約束
- map key type 不能是哪些類型？典型回答是：map的鍵類型不可以是function類型、map類型和slice類型。
  - Go 語言規範規定，在`鍵類型的值之間必須可以施加操作符==和!=`。(哈希碰撞: 不同值的哈希值是可能相同的)
    換句話說，鍵類型的值必須要支持判等操作。由於`函數類型、map類型和slice類型的值並不支持判等操作，所以map的鍵類型不能是這些類型`。
  - 另外，如果`鍵的類型是接口類型的，那麼key的實際類型也不能是上述三種類型`，否則在程序運行過程中會引發 panic（即運行時恐慌）
    ```go
    var badMap2 = map[interface{}]int{
      "1":   1,
      []int{2}: 2, // 這樣的聲明躲過了 Go 語言編譯器的檢查(因為從語法上說，這樣做是可以的),but result in panic。
      3:    3,
    }
    ```
    如果鍵的類型是數組類型，那麼還要確保該類型的元素類型不是函數類型、map類型或slice類型。
    鍵的類型是結構體類型，那麼還要保證其中字段的類型的合法性。比如map[[1][2][3][]string]int。

- key type 長度越短求哈希越快。類型的寬度是指它的單個值需要佔用的字節數。比如，bool、int8和uint8類型的一個值需要佔用的字節數都是1，因此這些類型的寬度就都是1(8bit)。
- 對array類型的值求哈希實際上是`依次求得它的每個元素的哈希值並進行合併`，所以速度就`取決於它的元素類型以及它的長度`。對一個數組來說，我可以任意改變其中的元素值，但在變化前後，它卻代表了兩個不同的key。
- 對struct類型的值求哈希實際上就是對它的所有字段值求哈希並進行合併，所以關鍵在於它的各個字段的類型以及字段的數量。
- 對於接口類型，具體的哈希算法，則由值的實際類型決定。

- 由於map是引用類型，當僅聲明而不初始化一個map的變量的時候，它的值會是nil。
- 在這樣僅聲明map變量上試圖通過key獲取對應的元素值，或者添加key-value，會成功嗎？
  `除了添加key-value，在一個值為nil的map上做任何操作都不會引起錯誤`。
  當試圖在一個值為nil的map中添加key-value的時候，Go 語言的運行時系統就會立即拋出一個 panic。
- 非原子操作需要加鎖， map並發讀寫需要加鎖，map操作不是並發安全的，判斷一個操作是否是原子的可以使用 `go run race `命令做數據的競爭檢測

## 10 | 通道的基本操作



## 14 | 接口類型的合理運用
- 接口類型聲明中的這些方法所代表的就是該接口的方法集合。一個接口的方法集合就是它的全部特徵。對於任何數據類型，只要它的方法集合中完全包含了一個接口的全部特徵（即全部的方法），那麼它就一定是這個接口的實現類型。(Duck typing)
- 判定一個數據類型的某一個方法實現,有兩個充分必要條件，
  1. 一個是“兩個方法的簽名需要完全一致”
  2. 另一個是“兩個方法的名稱要一模一樣”
- 怎樣才能讓一個接口變量的值真正為nil呢？只聲明它但不做初始化，or 直接把字面量nil賦給它。

- Go 語言團隊鼓勵我們聲明體量較小的接口，並建議我們通過這種接口間的組合來擴展程序、增加程序的靈活性。這是因為相比於包含很多方法的大接口而言，小接口可以更加專注地表達某一種能力或某一類特徵，同時也更容易被組合在一起。
- Go 語言標準庫代碼包io中的ReadWriteCloser接口和ReadWriter接口就是這樣的例子，它們都是由若干個小接口組合而成的。以io.ReadWriteCloser接口為例，它是由io.Reader、io.Writer和io.Closer這三個接口組成的。
  這三個接口都只包含了一個方法，是典型的小接口。它們中的每一個都只代表了一種能力，分別是讀出、寫入和關閉。們編寫這幾個小接口的實現類型通常會很容易。並且，一旦我們同時實現了它們，就等於實現了它們的組合接口io.ReadWriteCloser。即使我們只實現了io.Reader和io.Writer，那麼也等同於實現了io.ReadWriter接口，因為後者就是前兩個接口組成的。可以看到，這幾個io包中的接口共同組成了一個接口矩陣。它們既相互關聯又獨立存在。

## 15 | 關於指針的有限操作